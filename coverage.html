
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/flagset_manager.go (93.0%)</option>
				
				<option value="file1">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/gofeatureflag.go (0.0%)</option>
				
				<option value="file2">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/gofeatureflag_client.go (82.4%)</option>
				
				<option value="file3">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/gofeatureflag_retriever.go (64.0%)</option>
				
				<option value="file4">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/monitoring.go (92.9%)</option>
				
				<option value="file5">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/notifier_websocket.go (100.0%)</option>
				
				<option value="file6">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/websocket.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package service

import (
        "errors"
        "fmt"

        "github.com/google/uuid"
        ffclient "github.com/thomaspoignant/go-feature-flag"
        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/config"
        "github.com/thomaspoignant/go-feature-flag/notifier"
        "go.uber.org/zap"
)

const defaultFlagSetName = "default"

type flagsetManagerMode string

const (
        flagsetManagerModeDefault  flagsetManagerMode = "default"
        flagsetManagerModeFlagsets flagsetManagerMode = "flagsets"
)

// FlagsetManager is the interface for managing flagsets.
// It is used to retrieve the flagset linked to the API Key.
type FlagsetManager interface {
        // GetFlagSet returns the flag set linked to the API Key
        GetFlagSet(apiKey string) (*ffclient.GoFeatureFlag, error)
        // GetFlagSets returns all flag sets of the flagset manager
        GetFlagSets() (map[string]*ffclient.GoFeatureFlag, error)
        // GetDefaultFlagSet returns the default flagset
        GetDefaultFlagSet() *ffclient.GoFeatureFlag
        // IsDefaultFlagSet returns true if the manager is in default mode (no flagsets configured)
        IsDefaultFlagSet() bool
}

// flagsetManagerImpl is the internal implementation of FlagsetManager
type flagsetManagerImpl struct {
        // DefaultFlagSet is the flagset used when no API Key is provider.
        // It is the legacy way to handle feature flags in GO Feature Flag.
        // This is used only if no flag set is configured in the configuration file.
        DefaultFlagSet *ffclient.GoFeatureFlag

        // FlagSets is a map that stores the different instances of GoFeatureFlag (one per flagset)
        // It is used to retrieve the flagset linked to the API Key.
        FlagSets map[string]*ffclient.GoFeatureFlag

        // APIKeysToFlagSet is a map that stores the API Key linked to the flagset name.
        // It is used to retrieve the flagset linked to the API Key.
        APIKeysToFlagSet map[string]string

        // Config is the configuration of the relay proxy.
        // It is used to retrieve the configuration of the relay proxy.
        config *config.Config

        // Mode is the mode of the flagset manager.
        mode flagsetManagerMode
}

// NewFlagsetManager is creating a new FlagsetManager.
// It is used to retrieve the flagset linked to the API Key.
func NewFlagsetManager(config *config.Config, logger *zap.Logger, notifiers []notifier.Notifier) (FlagsetManager, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("configuration is nil")
        }</span>

        <span class="cov8" title="1">if len(config.FlagSets) == 0 </span><span class="cov8" title="1">{
                // in case you are using the relay proxy with flagsets, we create the flagsets and map them to the APIKeys.
                // note that the default configuration is ignored in this case.
                return newFlagsetManagerWithDefaultConfig(config, logger, notifiers)
        }</span>

        <span class="cov8" title="1">flagsetMngr, err := newFlagsetManagerWithFlagsets(config, logger, notifiers)
        if err != nil </span><span class="cov8" title="1">{
                return newFlagsetManagerWithDefaultConfig(config, logger, notifiers)
        }</span>
        <span class="cov8" title="1">return flagsetMngr, nil</span>
}

// newFlagsetManagerWithDefaultConfig is creating a new FlagsetManager with the default configuration.
// The default configuration is the top level configuration of the relay proxy.
func newFlagsetManagerWithDefaultConfig(c *config.Config, logger *zap.Logger, notifiers []notifier.Notifier) (FlagsetManager, error) <span class="cov8" title="1">{
        defaultFlagSet := config.FlagSet{
                Name: "default",
                CommonFlagSet: config.CommonFlagSet{
                        Retrievers:                      c.Retrievers,
                        Notifiers:                       c.Notifiers,
                        Exporters:                       c.Exporters,
                        FileFormat:                      c.FileFormat,
                        PollingInterval:                 c.PollingInterval,
                        StartWithRetrieverError:         c.StartWithRetrieverError,
                        EnablePollingJitter:             c.EnablePollingJitter,
                        DisableNotifierOnInit:           c.DisableNotifierOnInit,
                        EvaluationContextEnrichment:     c.EvaluationContextEnrichment,
                        PersistentFlagConfigurationFile: c.PersistentFlagConfigurationFile,
                },
        }
        client, err := NewGoFeatureFlagClient(&amp;defaultFlagSet, logger, notifiers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;flagsetManagerImpl{
                DefaultFlagSet: &amp;client,
                config:         c,
                mode:           flagsetManagerModeDefault,
        }, nil</span>
}

// newFlagsetManagerWithFlagsets is creating a new FlagsetManager with flagsets.
// It is used to create the flagsets and map them to the APIKeys.
func newFlagsetManagerWithFlagsets(config *config.Config, logger *zap.Logger, notifiers []notifier.Notifier) (FlagsetManager, error) <span class="cov8" title="1">{
        flagsets := make(map[string]*ffclient.GoFeatureFlag)
        apiKeysToFlagSet := make(map[string]string)

        for _, flagset := range config.FlagSets </span><span class="cov8" title="1">{
                client, err := NewGoFeatureFlagClient(&amp;flagset, logger, notifiers)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("failed to create goff client for flagset", zap.String("flagset", flagset.Name), zap.Error(err))
                        continue</span>
                }

                <span class="cov8" title="1">flagSetName := flagset.Name
                if flagSetName == "" || flagSetName == defaultFlagSetName </span><span class="cov8" title="1">{
                        // generating a default flagset name if not provided or equals to default
                        flagSetName = uuid.New().String()
                }</span>

                <span class="cov8" title="1">flagsets[flagSetName] = &amp;client
                for _, apiKey := range flagset.ApiKeys </span><span class="cov8" title="1">{
                        apiKeysToFlagSet[apiKey] = flagSetName
                }</span>
        }

        <span class="cov8" title="1">if len(flagsets) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("no flagset configured")
        }</span>

        <span class="cov8" title="1">return &amp;flagsetManagerImpl{
                FlagSets:         flagsets,
                APIKeysToFlagSet: apiKeysToFlagSet,
                config:           config,
                mode:             flagsetManagerModeFlagsets,
        }, nil</span>
}

// GetFlagSet is returning the flag set linked to the API Key
func (m *flagsetManagerImpl) GetFlagSet(apiKey string) (*ffclient.GoFeatureFlag, error) <span class="cov8" title="1">{
        switch m.mode </span>{
        case flagsetManagerModeFlagsets:<span class="cov8" title="1">
                if apiKey == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("no API key provided")
                }</span>
                <span class="cov8" title="1">return m.FlagSets[m.APIKeysToFlagSet[apiKey]], nil</span>
        default:<span class="cov8" title="1">
                return m.DefaultFlagSet, nil</span>
        }
}

// GetFlagSets returns the flag sets of the flagset manager.
func (m *flagsetManagerImpl) GetFlagSets() (map[string]*ffclient.GoFeatureFlag, error) <span class="cov8" title="1">{
        switch m.mode </span>{
        case flagsetManagerModeFlagsets:<span class="cov8" title="1">
                if len(m.FlagSets) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no flagsets configured")
                }</span>
                <span class="cov8" title="1">return m.FlagSets, nil</span>
        default:<span class="cov8" title="1">
                if m.DefaultFlagSet == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no default flagset configured")
                }</span>
                <span class="cov8" title="1">return map[string]*ffclient.GoFeatureFlag{
                        "default": m.DefaultFlagSet,
                }, nil</span>
        }
}

// GetDefaultFlagSet returns the default flagset
func (m *flagsetManagerImpl) GetDefaultFlagSet() *ffclient.GoFeatureFlag <span class="cov8" title="1">{
        return m.DefaultFlagSet
}</span>

// IsDefaultFlagSet returns true if the manager is in default mode (no flagsets configured)
func (m *flagsetManagerImpl) IsDefaultFlagSet() bool <span class="cov8" title="1">{
        return m.mode == flagsetManagerModeDefault
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package service

import (
        "context"

        ffclient "github.com/thomaspoignant/go-feature-flag"
        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/config"
        "github.com/thomaspoignant/go-feature-flag/notifier"
        "go.uber.org/zap"
)

type GoFeatureFlagService struct {
        goffClient map[string]*ffclient.GoFeatureFlag
}

// NewGoFeatureFlag creates a new GoFeatureFlag service.
func NewGoFeatureFlagService(ctx context.Context, proxyConf config.Config, logger zap.Logger) (GoFeatureFlagService, error) <span class="cov0" title="0">{
        clients := make(map[string]*ffclient.GoFeatureFlag)
        for _, flagSet := range proxyConf.FlagSets </span><span class="cov0" title="0">{
                c, err := NewGoFeatureFlagClient(&amp;flagSet, &amp;logger, []notifier.Notifier{})
                if err != nil </span><span class="cov0" title="0">{
                        return GoFeatureFlagService{}, err
                }</span>
                <span class="cov0" title="0">clients[flagSet.Name] = &amp;c</span>
        }

        <span class="cov0" title="0">return GoFeatureFlagService{
                goffClient: clients,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package service

import (
        "fmt"
        "log/slog"
        "time"

        "dario.cat/mergo"
        "github.com/IBM/sarama"
        awsConf "github.com/aws/aws-sdk-go-v2/config"
        slogzap "github.com/samber/slog-zap/v2"
        ffclient "github.com/thomaspoignant/go-feature-flag"
        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/config"
        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/config/kafka"
        "github.com/thomaspoignant/go-feature-flag/exporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/azureexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/fileexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/gcstorageexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/kafkaexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/kinesisexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/logsexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/pubsubexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/s3exporterv2"
        "github.com/thomaspoignant/go-feature-flag/exporter/sqsexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/webhookexporter"
        "github.com/thomaspoignant/go-feature-flag/notifier"
        "github.com/thomaspoignant/go-feature-flag/notifier/discordnotifier"
        "github.com/thomaspoignant/go-feature-flag/notifier/microsoftteamsnotifier"
        "github.com/thomaspoignant/go-feature-flag/notifier/slacknotifier"
        "github.com/thomaspoignant/go-feature-flag/notifier/webhooknotifier"
        "github.com/thomaspoignant/go-feature-flag/retriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/fileretriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/gcstorageretriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/redisretriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/s3retrieverv2"
        "go.uber.org/zap"
        "golang.org/x/net/context"
)

func NewGoFeatureFlagClient(
        cFlagSet *config.FlagSet,
        logger *zap.Logger,
        notifiers []notifier.Notifier,
) (ffclient.GoFeatureFlag, error) <span class="cov8" title="1">{
        var err error
        if cFlagSet == nil </span><span class="cov8" title="1">{
                return ffclient.GoFeatureFlag{}, fmt.Errorf("proxy config is empty")
        }</span>

        <span class="cov8" title="1">retrievers, err := initRetrievers(cFlagSet)
        if err != nil </span><span class="cov0" title="0">{
                return ffclient.GoFeatureFlag{}, err
        }</span>

        <span class="cov8" title="1">exporters, err := initDataExporters(cFlagSet)
        if err != nil </span><span class="cov0" title="0">{
                return ffclient.GoFeatureFlag{}, err
        }</span>

        <span class="cov8" title="1">notif := make([]notifier.Notifier, 0)
        if cFlagSet.Notifiers != nil </span><span class="cov0" title="0">{
                notif, err = initNotifier(cFlagSet.Notifiers)
                if err != nil </span><span class="cov0" title="0">{
                        return ffclient.GoFeatureFlag{}, err
                }</span>
        }

        <span class="cov8" title="1">notif = append(notif, notifiers...)

        f := ffclient.Config{
                PollingInterval: time.Duration(
                        cFlagSet.PollingInterval,
                ) * time.Millisecond,
                LeveledLogger: slog.New(
                        slogzap.Option{Level: slog.LevelDebug, Logger: logger}.NewZapHandler(),
                ),
                Context:                         context.Background(),
                Retrievers:                      retrievers,
                Notifiers:                       notif,
                FileFormat:                      cFlagSet.FileFormat,
                DataExporters:                   exporters,
                StartWithRetrieverError:         cFlagSet.StartWithRetrieverError,
                EnablePollingJitter:             cFlagSet.EnablePollingJitter,
                DisableNotifierOnInit:           cFlagSet.DisableNotifierOnInit,
                EvaluationContextEnrichment:     cFlagSet.EvaluationContextEnrichment,
                PersistentFlagConfigurationFile: cFlagSet.PersistentFlagConfigurationFile,
        }
        client, err := ffclient.New(f)
        if err != nil </span><span class="cov8" title="1">{
                return ffclient.GoFeatureFlag{}, err
        }</span>
        <span class="cov8" title="1">return *client, nil</span>
}

// initRetrievers initialize the retrievers based on the configuration
// it handles both the `retriever` and `retrievers` fields
func initRetrievers(proxyConf *config.FlagSet) ([]retriever.Retriever, error) <span class="cov8" title="1">{
        retrievers := make([]retriever.Retriever, 0)
        if proxyConf.Retrievers != nil </span><span class="cov8" title="1">{
                for _, r := range *proxyConf.Retrievers </span><span class="cov8" title="1">{
                        currentRetriever, err := initRetriever(&amp;r)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">retrievers = append(retrievers, currentRetriever)</span>
                }
        }
        <span class="cov8" title="1">return retrievers, nil</span>
}

// initRetriever initialize the retriever based on the configuration
func initRetriever(c *config.RetrieverConf) (retriever.Retriever, error) <span class="cov8" title="1">{
        retrieverTimeout := config.DefaultRetriever.Timeout
        if c.Timeout != 0 </span><span class="cov8" title="1">{
                retrieverTimeout = time.Duration(c.Timeout) * time.Millisecond
        }</span>
        <span class="cov8" title="1">switch c.Kind </span>{
        case config.GitHubRetriever:<span class="cov8" title="1">
                return initGithubRetriever(c, retrieverTimeout), nil</span>
        case config.GitlabRetriever:<span class="cov8" title="1">
                return initGitlabRetriever(c, retrieverTimeout), nil</span>
        case config.BitbucketRetriever:<span class="cov8" title="1">
                return initBitbucketRetriever(c, retrieverTimeout), nil</span>
        case config.FileRetriever:<span class="cov8" title="1">
                return &amp;fileretriever.Retriever{Path: c.Path}, nil</span>
        case config.S3Retriever:<span class="cov8" title="1">
                awsConfig, err := awsConf.LoadDefaultConfig(context.Background())
                return &amp;s3retrieverv2.Retriever{Bucket: c.Bucket, Item: c.Item, AwsConfig: &amp;awsConfig}, err</span>
        case config.HTTPRetriever:<span class="cov8" title="1">
                return initHTTPRetriever(c, retrieverTimeout), nil</span>
        case config.GoogleStorageRetriever:<span class="cov8" title="1">
                return &amp;gcstorageretriever.Retriever{Bucket: c.Bucket, Object: c.Object}, nil</span>
        case config.KubernetesRetriever:<span class="cov0" title="0">
                return initK8sRetriever(c)</span>
        case config.MongoDBRetriever:<span class="cov0" title="0">
                return initMongoRetriever(c), nil</span>
        case config.RedisRetriever:<span class="cov0" title="0">
                return &amp;redisretriever.Retriever{Options: c.RedisOptions, Prefix: c.RedisPrefix}, nil</span>
        case config.AzBlobStorageRetriever:<span class="cov0" title="0">
                return initAzBlobRetriever(c), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("invalid retriever: kind \"%s\" "+
                        "is not supported", c.Kind)</span>
        }
}

// initDataExporters initialize the exporters based on the configuration
// it handles both the `exporter` and `exporters` fields.
func initDataExporters(proxyConf *config.FlagSet) ([]ffclient.DataExporter, error) <span class="cov8" title="1">{
        exporters := make([]ffclient.DataExporter, 0)
        if proxyConf.Exporters != nil </span><span class="cov8" title="1">{
                for _, e := range *proxyConf.Exporters </span><span class="cov8" title="1">{
                        currentExporter, err := initDataExporter(&amp;e)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">exporters = append(exporters, currentExporter)</span>
                }
        }
        <span class="cov8" title="1">return exporters, nil</span>
}

func initDataExporter(c *config.ExporterConf) (ffclient.DataExporter, error) <span class="cov8" title="1">{
        exporterEventType := c.ExporterEventType
        if exporterEventType == "" </span><span class="cov8" title="1">{
                exporterEventType = config.DefaultExporter.ExporterEventType
        }</span>
        <span class="cov8" title="1">dataExp := ffclient.DataExporter{
                FlushInterval: func() time.Duration </span><span class="cov8" title="1">{
                        if c.FlushInterval != 0 </span><span class="cov8" title="1">{
                                return time.Duration(c.FlushInterval) * time.Millisecond
                        }</span>
                        <span class="cov8" title="1">return config.DefaultExporter.FlushInterval</span>
                }(),
                MaxEventInMemory: func() int64 <span class="cov8" title="1">{
                        if c.MaxEventInMemory != 0 </span><span class="cov8" title="1">{
                                return c.MaxEventInMemory
                        }</span>
                        <span class="cov8" title="1">return config.DefaultExporter.MaxEventInMemory</span>
                }(),
                ExporterEventType: exporterEventType,
        }

        <span class="cov8" title="1">var err error
        dataExp.Exporter, err = createExporter(c)
        if err != nil </span><span class="cov8" title="1">{
                return ffclient.DataExporter{}, err
        }</span>

        <span class="cov8" title="1">return dataExp, nil</span>
}

// nolint: funlen
func createExporter(c *config.ExporterConf) (exporter.CommonExporter, error) <span class="cov8" title="1">{
        format := config.DefaultExporter.Format
        if c.Format != "" </span><span class="cov0" title="0">{
                format = c.Format
        }</span>

        <span class="cov8" title="1">filename := config.DefaultExporter.FileName
        if c.Filename != "" </span><span class="cov0" title="0">{
                filename = c.Filename
        }</span>

        <span class="cov8" title="1">csvTemplate := config.DefaultExporter.CsvFormat
        if c.CsvTemplate != "" </span><span class="cov0" title="0">{
                csvTemplate = c.CsvTemplate
        }</span>

        <span class="cov8" title="1">parquetCompressionCodec := config.DefaultExporter.ParquetCompressionCodec
        if c.ParquetCompressionCodec != "" </span><span class="cov8" title="1">{
                parquetCompressionCodec = c.ParquetCompressionCodec
        }</span>

        <span class="cov8" title="1">switch c.Kind </span>{
        case config.WebhookExporter:<span class="cov8" title="1">
                return &amp;webhookexporter.Exporter{
                        EndpointURL: c.EndpointURL,
                        Secret:      c.Secret,
                        Meta:        c.Meta,
                        Headers:     c.Headers,
                }, nil</span>
        case config.FileExporter:<span class="cov8" title="1">
                return &amp;fileexporter.Exporter{
                        Format:                  format,
                        OutputDir:               c.OutputDir,
                        Filename:                filename,
                        CsvTemplate:             csvTemplate,
                        ParquetCompressionCodec: parquetCompressionCodec,
                }, nil</span>
        case config.LogExporter:<span class="cov8" title="1">
                return &amp;logsexporter.Exporter{
                        LogFormat: func() string </span><span class="cov8" title="1">{
                                if c.LogFormat != "" </span><span class="cov0" title="0">{
                                        return c.LogFormat
                                }</span>
                                <span class="cov8" title="1">return config.DefaultExporter.LogFormat</span>
                        }(),
                }, nil
        case config.S3Exporter:<span class="cov8" title="1">
                awsConfig, err := awsConf.LoadDefaultConfig(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return &amp;s3exporterv2.Exporter{
                        Bucket:                  c.Bucket,
                        Format:                  format,
                        S3Path:                  c.Path,
                        Filename:                filename,
                        CsvTemplate:             csvTemplate,
                        ParquetCompressionCodec: parquetCompressionCodec,
                        AwsConfig:               &amp;awsConfig,
                }, nil</span>
        case config.KinesisExporter:<span class="cov8" title="1">
                awsConfig, err := awsConf.LoadDefaultConfig(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;kinesisexporter.Exporter{
                        Format:    format,
                        AwsConfig: &amp;awsConfig,
                        Settings: kinesisexporter.NewSettings(
                                kinesisexporter.WithStreamArn(c.StreamArn),
                                kinesisexporter.WithStreamName(c.StreamName),
                        ),
                }, nil</span>
        case config.GoogleStorageExporter:<span class="cov8" title="1">
                return &amp;gcstorageexporter.Exporter{
                        Bucket:                  c.Bucket,
                        Format:                  format,
                        Path:                    c.Path,
                        Filename:                filename,
                        CsvTemplate:             csvTemplate,
                        ParquetCompressionCodec: parquetCompressionCodec,
                }, nil</span>
        case config.SQSExporter:<span class="cov8" title="1">
                awsConfig, err := awsConf.LoadDefaultConfig(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;sqsexporter.Exporter{
                        QueueURL:  c.QueueURL,
                        AwsConfig: &amp;awsConfig,
                }, nil</span>
        case config.KafkaExporter:<span class="cov8" title="1">
                settings, err := setKafkaConfig(c.Kafka)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;kafkaexporter.Exporter{
                        Format:   format,
                        Settings: settings,
                }, nil</span>
        case config.PubSubExporter:<span class="cov8" title="1">
                return &amp;pubsubexporter.Exporter{
                        ProjectID: c.ProjectID,
                        Topic:     c.Topic,
                }, nil</span>
        case config.AzureExporter:<span class="cov8" title="1">
                return &amp;azureexporter.Exporter{
                        Container:               c.Container,
                        Format:                  format,
                        Path:                    c.Path,
                        Filename:                filename,
                        CsvTemplate:             csvTemplate,
                        ParquetCompressionCodec: parquetCompressionCodec,
                        AccountKey:              c.AccountKey,
                        AccountName:             c.AccountName,
                }, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("invalid exporter: kind \"%s\" is not supported", c.Kind)</span>
        }
}

// setKafkaConfig set the kafka configuration based on the default configuration
// it will initialize the default configuration and merge it with the changes from the user.
func setKafkaConfig(k kafkaexporter.Settings) (kafkaexporter.Settings, error) <span class="cov8" title="1">{
        c := kafkaexporter.Settings{
                Topic:     k.Topic,
                Addresses: k.Addresses,
        }

        if k.Config == nil </span><span class="cov8" title="1">{
                return c, nil
        }</span>
        <span class="cov8" title="1">saramaConfig := sarama.NewConfig()
        err := mergo.Merge(saramaConfig, k.Config)
        if err != nil </span><span class="cov0" title="0">{
                return kafkaexporter.Settings{}, err
        }</span>
        <span class="cov8" title="1">saramaConfig.Producer.Return.Errors = true

        switch saramaConfig.Net.SASL.Mechanism </span>{
        case sarama.SASLTypeSCRAMSHA256:<span class="cov8" title="1">
                saramaConfig.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient </span><span class="cov0" title="0">{
                        return &amp;kafka.XDGSCRAMClient{HashGeneratorFcn: kafka.SHA256}
                }</span>
        case sarama.SASLTypeSCRAMSHA512:<span class="cov8" title="1">
                saramaConfig.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient </span><span class="cov0" title="0">{
                        return &amp;kafka.XDGSCRAMClient{HashGeneratorFcn: kafka.SHA512}
                }</span>
        }
        <span class="cov8" title="1">c.Config = saramaConfig
        return c, nil</span>
}

func initNotifier(c []config.NotifierConf) ([]notifier.Notifier, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var notifiers []notifier.Notifier

        for _, cNotif := range c </span><span class="cov8" title="1">{
                switch cNotif.Kind </span>{
                case config.SlackNotifier:<span class="cov8" title="1">
                        if cNotif.WebhookURL == "" &amp;&amp; cNotif.SlackWebhookURL != "" </span><span class="cov0" title="0">{ // nolint
                                zap.L().Warn("slackWebhookURL field is deprecated, please use webhookURL instead")
                                cNotif.WebhookURL = cNotif.SlackWebhookURL // nolint
                        }</span>
                        <span class="cov8" title="1">notifiers = append(
                                notifiers,
                                &amp;slacknotifier.Notifier{SlackWebhookURL: cNotif.WebhookURL},
                        )</span>
                case config.MicrosoftTeamsNotifier:<span class="cov8" title="1">
                        notifiers = append(
                                notifiers,
                                &amp;microsoftteamsnotifier.Notifier{
                                        MicrosoftTeamsWebhookURL: cNotif.WebhookURL,
                                },
                        )</span>
                case config.WebhookNotifier:<span class="cov8" title="1">
                        notifiers = append(notifiers,
                                &amp;webhooknotifier.Notifier{
                                        Secret:      cNotif.Secret,
                                        EndpointURL: cNotif.EndpointURL,
                                        Meta:        cNotif.Meta,
                                        Headers:     cNotif.Headers,
                                },
                        )</span>
                case config.DiscordNotifier:<span class="cov8" title="1">
                        notifiers = append(
                                notifiers,
                                &amp;discordnotifier.Notifier{DiscordWebhookURL: cNotif.WebhookURL},
                        )</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid notifier: kind \"%s\" is not supported", cNotif.Kind)</span>
                }
        }
        <span class="cov8" title="1">return notifiers, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package service

import (
        "time"

        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/config"
        azblobretriever "github.com/thomaspoignant/go-feature-flag/retriever/azblobstorageretriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/bitbucketretriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/githubretriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/gitlabretriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/httpretriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/k8sretriever"
        "github.com/thomaspoignant/go-feature-flag/retriever/mongodbretriever"
        "k8s.io/client-go/rest"
)

func initGithubRetriever(
        c *config.RetrieverConf,
        retrieverTimeout time.Duration,
) *githubretriever.Retriever <span class="cov8" title="1">{
        token := c.AuthToken
        if token == "" &amp;&amp; c.GithubToken != "" </span><span class="cov8" title="1">{ // nolint: staticcheck
                token = c.GithubToken // nolint: staticcheck
        }</span>
        <span class="cov8" title="1">return &amp;githubretriever.Retriever{
                RepositorySlug: c.RepositorySlug,
                Branch: func() string </span><span class="cov8" title="1">{
                        if c.Branch == "" </span><span class="cov8" title="1">{
                                return config.DefaultRetriever.GitBranch
                        }</span>
                        <span class="cov0" title="0">return c.Branch</span>
                }(),
                FilePath:    c.Path,
                GithubToken: token,
                Timeout:     retrieverTimeout,
        }
}

func initGitlabRetriever(
        c *config.RetrieverConf,
        retrieverTimeout time.Duration,
) *gitlabretriever.Retriever <span class="cov8" title="1">{
        return &amp;gitlabretriever.Retriever{
                BaseURL: c.BaseURL,
                Branch: func() string </span><span class="cov8" title="1">{
                        if c.Branch == "" </span><span class="cov8" title="1">{
                                return config.DefaultRetriever.GitBranch
                        }</span>
                        <span class="cov0" title="0">return c.Branch</span>
                }(),
                FilePath:       c.Path,
                GitlabToken:    c.AuthToken,
                RepositorySlug: c.RepositorySlug,
                Timeout:        retrieverTimeout,
        }
}

func initBitbucketRetriever(
        c *config.RetrieverConf,
        retrieverTimeout time.Duration,
) *bitbucketretriever.Retriever <span class="cov8" title="1">{
        return &amp;bitbucketretriever.Retriever{
                RepositorySlug: c.RepositorySlug,
                Branch: func() string </span><span class="cov8" title="1">{
                        if c.Branch == "" </span><span class="cov8" title="1">{
                                return config.DefaultRetriever.GitBranch
                        }</span>
                        <span class="cov8" title="1">return c.Branch</span>
                }(),
                FilePath:       c.Path,
                BitBucketToken: c.AuthToken,
                BaseURL:        c.BaseURL,
                Timeout:        retrieverTimeout,
        }
}

func initHTTPRetriever(
        c *config.RetrieverConf,
        retrieverTimeout time.Duration,
) *httpretriever.Retriever <span class="cov8" title="1">{
        return &amp;httpretriever.Retriever{
                URL: c.URL,
                Method: func() string </span><span class="cov8" title="1">{
                        if c.HTTPMethod == "" </span><span class="cov8" title="1">{
                                return config.DefaultRetriever.HTTPMethod
                        }</span>
                        <span class="cov0" title="0">return c.HTTPMethod</span>
                }(), Body: c.HTTPBody, Header: c.HTTPHeaders, Timeout: retrieverTimeout}
}

func initK8sRetriever(c *config.RetrieverConf) (*k8sretriever.Retriever, error) <span class="cov0" title="0">{
        client, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;k8sretriever.Retriever{
                Namespace:     c.Namespace,
                ConfigMapName: c.ConfigMap,
                Key:           c.Key,
                ClientConfig:  *client,
        }, nil</span>
}

func initMongoRetriever(c *config.RetrieverConf) *mongodbretriever.Retriever <span class="cov0" title="0">{
        return &amp;mongodbretriever.Retriever{
                Database:   c.Database,
                URI:        c.URI,
                Collection: c.Collection,
        }
}</span>

func initAzBlobRetriever(c *config.RetrieverConf) *azblobretriever.Retriever <span class="cov0" title="0">{
        return &amp;azblobretriever.Retriever{
                Container:   c.Container,
                Object:      c.Object,
                AccountName: c.AccountName,
                AccountKey:  c.AccountKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package service

import (
        "fmt"
        "time"

        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/model"
)

// Monitoring is the interface of the monitoring service
type Monitoring interface {
        Health() model.HealthResponse
        Info() (model.InfoResponse, error)
}

// NewMonitoring creates a new implementation of Monitoring
func NewMonitoring(flagsetManager FlagsetManager) Monitoring <span class="cov8" title="1">{
        return &amp;monitoringImpl{
                flagsetManager: flagsetManager,
        }
}</span>

// monitoringImpl is one implementation of the Monitoring interface
type monitoringImpl struct {
        flagsetManager FlagsetManager
}

// Health returns a static object to show that the server is initialized
func (m *monitoringImpl) Health() model.HealthResponse <span class="cov8" title="1">{
        return model.HealthResponse{
                Initialized: true,
        }
}</span>

// Info returns information about the relay-proxy
func (m *monitoringImpl) Info() (model.InfoResponse, error) <span class="cov8" title="1">{
        flagSets, err := m.flagsetManager.GetFlagSets()
        if err != nil </span><span class="cov8" title="1">{
                return model.InfoResponse{}, err
        }</span>

        <span class="cov8" title="1">if m.flagsetManager.IsDefaultFlagSet() </span><span class="cov8" title="1">{
                if m.flagsetManager.GetDefaultFlagSet() == nil </span><span class="cov0" title="0">{
                        return model.InfoResponse{}, fmt.Errorf("no default flagset configured")
                }</span>
                <span class="cov8" title="1">cacheRefreshDate := m.flagsetManager.GetDefaultFlagSet().GetCacheRefreshDate()
                return model.InfoResponse{
                        LatestCacheRefresh: &amp;cacheRefreshDate,
                }, nil</span>
        }

        <span class="cov8" title="1">refreshDates := make(map[string]time.Time, len(flagSets))
        for flagsetName, flagset := range flagSets </span><span class="cov8" title="1">{
                refreshDates[flagsetName] = flagset.GetCacheRefreshDate()
        }</span>
        <span class="cov8" title="1">return model.InfoResponse{
                Flagsets: refreshDates,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package service

import (
        "github.com/thomaspoignant/go-feature-flag/notifier"
)

type notifierWebsocket struct {
        websocketService WebsocketService
}

func NewNotifierWebsocket(websocketService WebsocketService) notifier.Notifier <span class="cov8" title="1">{
        return &amp;notifierWebsocket{
                websocketService: websocketService,
        }
}</span>

func (n *notifierWebsocket) Notify(diff notifier.DiffCache) error <span class="cov8" title="1">{
        n.websocketService.BroadcastFlagChanges(diff)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package service

import (
        "sync"

        "github.com/thomaspoignant/go-feature-flag/notifier"
)

// WebsocketConn is an interface to be able to mock websocket.Conn
type WebsocketConn interface {
        WriteJSON(v interface{}) error
}

// WebsocketService is the service interface that handle the websocket connections
// This service is able to broadcast a notification to all the open websockets
type WebsocketService interface {
        // Register is adding the connection to the list of open connection.
        Register(c WebsocketConn)
        // Deregister is removing the connection from the list of open connection.
        Deregister(c WebsocketConn)
        // BroadcastFlagChanges is sending the diff cache struct to the client.
        BroadcastFlagChanges(diff notifier.DiffCache)
        // Close deregister all open connections.
        Close()
}

// NewWebsocketService is a constructor to create a new WebsocketService.
func NewWebsocketService() WebsocketService <span class="cov8" title="1">{
        return &amp;websocketServiceImpl{
                clients: map[WebsocketConn]interface{}{},
                mutex:   &amp;sync.RWMutex{},
        }
}</span>

// websocketServiceImpl is the implementation of the interface.
type websocketServiceImpl struct {
        clients map[WebsocketConn]interface{}
        mutex   *sync.RWMutex
}

// BroadcastFlagChanges is sending a string to all the open connection.
func (w *websocketServiceImpl) BroadcastFlagChanges(diff notifier.DiffCache) <span class="cov8" title="1">{
        w.mutex.RLock()
        defer w.mutex.RUnlock()
        for c := range w.clients </span><span class="cov8" title="1">{
                err := c.WriteJSON(diff)
                if err != nil </span><span class="cov8" title="1">{
                        w.mutex.RUnlock()
                        w.Deregister(c)
                        w.mutex.RLock()
                }</span>
        }
}

// Register is adding the connection to the list of open connection.
func (w *websocketServiceImpl) Register(c WebsocketConn) <span class="cov8" title="1">{
        w.mutex.Lock()
        defer w.mutex.Unlock()
        w.clients[c] = struct{}{}
}</span>

// Deregister is removing the connection from the list of open connection.
func (w *websocketServiceImpl) Deregister(c WebsocketConn) <span class="cov8" title="1">{
        w.mutex.Lock()
        defer w.mutex.Unlock()
        delete(w.clients, c)
}</span>

// Close deregister all open connections.
func (w *websocketServiceImpl) Close() <span class="cov8" title="1">{
        w.mutex.Lock()
        defer w.mutex.Unlock()
        for c := range w.clients </span><span class="cov8" title="1">{
                delete(w.clients, c)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
