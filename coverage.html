
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/flagset_manager.go (75.9%)</option>
				
				<option value="file1">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/gofeatureflag_client.go (80.6%)</option>
				
				<option value="file2">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/monitoring.go (100.0%)</option>
				
				<option value="file3">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/notifier_websocket.go (100.0%)</option>
				
				<option value="file4">github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/service/websocket.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package service

import (
        "errors"
        "fmt"
        "sync"

        "github.com/google/go-cmp/cmp"
        "github.com/google/go-cmp/cmp/cmpopts"
        "github.com/google/uuid"
        ffclient "github.com/thomaspoignant/go-feature-flag"
        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/config"
        "github.com/thomaspoignant/go-feature-flag/notifier"
        "github.com/thomaspoignant/go-feature-flag/utils"
        "go.uber.org/zap"
)

type flagsetManagerMode string

const (
        flagsetManagerModeDefault  flagsetManagerMode = "default"
        flagsetManagerModeFlagsets flagsetManagerMode = "flagsets"
)

// FlagsetManager is the interface for managing flagsets.
// It is used to retrieve the flagset linked to the API Key.
type FlagsetManager interface {
        // FlagSet returns the flag set linked to the API Key
        FlagSet(apiKey string) (*ffclient.GoFeatureFlag, error)
        // FlagSetName returns the name of the flagset linked to the API Key
        FlagSetName(apiKey string) (string, error)
        // AllFlagSets returns all flag sets of the flagset manager
        AllFlagSets() (map[string]*ffclient.GoFeatureFlag, error)
        // Default returns the default flagset
        Default() *ffclient.GoFeatureFlag
        // IsDefaultFlagSet returns true if the manager is in default mode (no flagsets configured)
        IsDefaultFlagSet() bool
        // Close closes the flagset manager
        Close()
        // OnConfigChange is called when the configuration changes
        OnConfigChange(newConfig *config.Config)
}

// flagsetManagerImpl is the internal implementation of FlagsetManager
type flagsetManagerImpl struct {
        // DefaultFlagSet is the flagset used when no API Key is provider.
        // It is the legacy way to handle feature flags in GO Feature Flag.
        // This is used only if no flag set is configured in the configuration file.
        DefaultFlagSet *ffclient.GoFeatureFlag

        // FlagSets is a map that stores the different instances of GoFeatureFlag (one per flagset)
        // It is used to retrieve the flagset linked to the API Key.
        FlagSets map[string]*ffclient.GoFeatureFlag

        // APIKeysToFlagSetName is a map that stores the API Key linked to the flagset name.
        // It is used to retrieve the flagset linked to the API Key.
        APIKeysToFlagSetName map[string]string

        // apiKeysMutex protects concurrent access to APIKeysToFlagSetName
        apiKeysMutex sync.RWMutex

        // Config is the configuration of the relay proxy.
        // It is used to retrieve the configuration of the relay proxy.
        config *config.Config

        // Mode is the mode of the flagset manager.
        mode flagsetManagerMode

        // Logger is the logger for the flagset manager.
        logger *zap.Logger
}

// NewFlagsetManager is creating a new FlagsetManager.
// It is used to retrieve the flagset linked to the API Key.
func NewFlagsetManager(
        config *config.Config, logger *zap.Logger, notifiers []notifier.Notifier) (FlagsetManager, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("configuration is nil")
        }</span>

        <span class="cov8" title="1">var flagsetMngr FlagsetManager
        var err error
        if config.IsUsingFlagsets() </span><span class="cov8" title="1">{
                // flagsets mode: create flagsets based on the `flagsets` array in the configuration.
                // The top-level retriever/exporter/etc. configuration is ignored in this mode.
                flagsetMngr, err = newFlagsetManagerWithFlagsets(config, logger, notifiers)
        }</span> else<span class="cov8" title="1"> {
                // default mode: use the top-level configuration to create a single default flagset.
                flagsetMngr, err = newFlagsetManagerWithDefaultConfig(config, logger, notifiers)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // Attach a callback to the flagset manager to be called when the configuration changes
        <span class="cov8" title="1">config.AttachConfigChangeCallback(flagsetMngr.OnConfigChange)
        return flagsetMngr, nil</span>
}

// newFlagsetManagerWithDefaultConfig is creating a new FlagsetManager with the default configuration.
// The default configuration is the top level configuration of the relay proxy.
func newFlagsetManagerWithDefaultConfig(
        c *config.Config, logger *zap.Logger, notifiers []notifier.Notifier) (FlagsetManager, error) <span class="cov8" title="1">{
        defaultFlagSet := config.FlagSet{
                Name: utils.DefaultFlagSetName,
                CommonFlagSet: config.CommonFlagSet{
                        Retriever:                       c.Retriever,
                        Retrievers:                      c.Retrievers,
                        Notifiers:                       c.Notifiers,
                        Exporter:                        c.Exporter,
                        Exporters:                       c.Exporters,
                        FileFormat:                      c.FileFormat,
                        PollingInterval:                 c.PollingInterval,
                        StartWithRetrieverError:         c.StartWithRetrieverError,
                        EnablePollingJitter:             c.EnablePollingJitter,
                        DisableNotifierOnInit:           c.DisableNotifierOnInit,
                        EvaluationContextEnrichment:     c.EvaluationContextEnrichment,
                        PersistentFlagConfigurationFile: c.PersistentFlagConfigurationFile,
                },
        }
        client, err := NewGoFeatureFlagClient(&amp;defaultFlagSet, logger, notifiers)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;flagsetManagerImpl{
                DefaultFlagSet: client,
                config:         c,
                mode:           flagsetManagerModeDefault,
                logger:         logger,
        }, nil</span>
}

// newFlagsetManagerWithFlagsets is creating a new FlagsetManager with flagsets.
// It is used to create the flagsets and map them to the APIKeys.
func newFlagsetManagerWithFlagsets(
        config *config.Config, logger *zap.Logger, notifiers []notifier.Notifier) (FlagsetManager, error) <span class="cov8" title="1">{
        flagsets := make(map[string]*ffclient.GoFeatureFlag)
        apiKeysToFlagSet := make(map[string]string)

        for index, flagset := range config.FlagSets </span><span class="cov8" title="1">{
                client, err := NewGoFeatureFlagClient(&amp;flagset, logger, notifiers)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error(
                                "failed to create goff client for flagset",
                                zap.Int("flagset_index", index),
                                zap.String("flagset", flagset.Name),
                                zap.Error(err),
                        )
                        continue</span>
                }

                <span class="cov8" title="1">flagSetName := flagset.Name
                if flagSetName == "" || flagSetName == utils.DefaultFlagSetName </span><span class="cov8" title="1">{
                        // generating a default flagset name if not provided or equals to default
                        flagSetName = uuid.New().String()

                        startLog := "no flagset name provided"
                        if flagset.Name == utils.DefaultFlagSetName </span><span class="cov8" title="1">{
                                startLog = "using 'default' as a flagset name"
                        }</span>
                        <span class="cov8" title="1">logMessage := startLog + ", generating a default flagset name. This is not recommended. " +
                                "Not having a flagset name will not allow you to change API Keys associated to the flagset during runtime."
                        logger.Warn(logMessage, zap.String("flagset", flagSetName))</span>
                }

                <span class="cov8" title="1">flagsets[flagSetName] = client
                for _, apiKey := range flagset.APIKeys </span><span class="cov8" title="1">{
                        apiKeysToFlagSet[apiKey] = flagSetName
                }</span>
        }

        <span class="cov8" title="1">if len(flagsets) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("no flagset configured")
        }</span>

        <span class="cov8" title="1">return &amp;flagsetManagerImpl{
                FlagSets:             flagsets,
                APIKeysToFlagSetName: apiKeysToFlagSet,
                config:               config,
                mode:                 flagsetManagerModeFlagsets,
                logger:               logger,
        }, nil</span>
}

// FlagSet is returning the flag set linked to the API Key
func (m *flagsetManagerImpl) FlagSet(apiKey string) (*ffclient.GoFeatureFlag, error) <span class="cov8" title="1">{
        switch m.mode </span>{
        case flagsetManagerModeFlagsets:<span class="cov8" title="1">
                if apiKey == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("no API key provided")
                }</span>

                <span class="cov8" title="1">m.apiKeysMutex.RLock()
                flagsetName, exists := m.APIKeysToFlagSetName[apiKey]
                if !exists </span><span class="cov8" title="1">{
                        m.apiKeysMutex.RUnlock()
                        return nil, fmt.Errorf("flagset not found for API key")
                }</span>
                <span class="cov8" title="1">flagset, exists := m.FlagSets[flagsetName]
                m.apiKeysMutex.RUnlock()
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("impossible to find the flagset with the name %s", flagsetName)
                }</span>
                <span class="cov8" title="1">return flagset, nil</span>
        default:<span class="cov8" title="1">
                if m.DefaultFlagSet == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no configured flagset")
                }</span>
                <span class="cov8" title="1">return m.DefaultFlagSet, nil</span>
        }
}

// FlagSetName returns the name of the flagset linked to the API Key
func (m *flagsetManagerImpl) FlagSetName(apiKey string) (string, error) <span class="cov8" title="1">{
        switch m.mode </span>{
        case flagsetManagerModeFlagsets:<span class="cov8" title="1">
                m.apiKeysMutex.RLock()
                name, ok := m.APIKeysToFlagSetName[apiKey]
                m.apiKeysMutex.RUnlock()
                if ok </span><span class="cov8" title="1">{
                        return name, nil
                }</span>
                <span class="cov8" title="1">return "", fmt.Errorf("no flag set associated to the API key")</span>
        default:<span class="cov8" title="1">
                return utils.DefaultFlagSetName, nil</span>
        }
}

// AllFlagSets returns the flag sets of the flagset manager.
func (m *flagsetManagerImpl) AllFlagSets() (map[string]*ffclient.GoFeatureFlag, error) <span class="cov8" title="1">{
        switch m.mode </span>{
        case flagsetManagerModeFlagsets:<span class="cov8" title="1">
                m.apiKeysMutex.RLock()
                defer m.apiKeysMutex.RUnlock()
                if len(m.FlagSets) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no flagsets configured")
                }</span>
                // Return a copy to avoid external modifications
                <span class="cov8" title="1">result := make(map[string]*ffclient.GoFeatureFlag, len(m.FlagSets))
                for k, v := range m.FlagSets </span><span class="cov8" title="1">{
                        result[k] = v
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        default:<span class="cov8" title="1">
                if m.DefaultFlagSet == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no default flagset configured")
                }</span>
                <span class="cov8" title="1">return map[string]*ffclient.GoFeatureFlag{
                        utils.DefaultFlagSetName: m.DefaultFlagSet,
                }, nil</span>
        }
}

// Default returns the default flagset
func (m *flagsetManagerImpl) Default() *ffclient.GoFeatureFlag <span class="cov8" title="1">{
        return m.DefaultFlagSet
}</span>

// IsDefaultFlagSet returns true if the manager is in default mode (no flagsets configured)
func (m *flagsetManagerImpl) IsDefaultFlagSet() bool <span class="cov8" title="1">{
        return m.mode == flagsetManagerModeDefault
}</span>

// Close closes the flagset manager
func (m *flagsetManagerImpl) Close() <span class="cov8" title="1">{
        if m.DefaultFlagSet != nil </span><span class="cov8" title="1">{
                m.DefaultFlagSet.Close()
        }</span>
        <span class="cov8" title="1">m.apiKeysMutex.RLock()
        flagsets := make([]*ffclient.GoFeatureFlag, 0, len(m.FlagSets))
        for _, flagset := range m.FlagSets </span><span class="cov8" title="1">{
                flagsets = append(flagsets, flagset)
        }</span>
        <span class="cov8" title="1">m.apiKeysMutex.RUnlock()
        for _, flagset := range flagsets </span><span class="cov8" title="1">{
                flagset.Close()
        }</span>
}

// OnConfigChange is called when the configuration changes
func (m *flagsetManagerImpl) OnConfigChange(newConfig *config.Config) <span class="cov8" title="1">{
        if err := newConfig.IsValid(); err != nil </span><span class="cov8" title="1">{
                m.logger.Error("the new configuration is invalid, it will not be applied", zap.Error(err))
                m.logger.Debug("invalid configuration:", zap.Error(err), zap.Any("newConfig", newConfig))
                return
        }</span>

        // dont allow to switch from default to flagsets mode (or the opposite) during runtime
        <span class="cov8" title="1">if (newConfig.IsUsingFlagsets() &amp;&amp; m.mode == flagsetManagerModeDefault) ||
                (!newConfig.IsUsingFlagsets() &amp;&amp; m.mode == flagsetManagerModeFlagsets) </span><span class="cov8" title="1">{
                m.logger.Error("switching from default to flagsets mode (or the opposite) is not supported during runtime")
                return
        }</span>

        <span class="cov8" title="1">switch m.mode </span>{
        case flagsetManagerModeDefault:<span class="cov8" title="1">
                m.onConfigChangeWithDefault(newConfig)</span>
        case flagsetManagerModeFlagsets:<span class="cov8" title="1">
                m.onConfigChangeWithFlagsets(newConfig)</span>
        }
}

// onConfigChangeWithFlagsets is called when the configuration changes in flagsets mode.
// It handles additions, removals, modifications, and API key changes for flagsets.
func (m *flagsetManagerImpl) onConfigChangeWithFlagsets(newConfig *config.Config) <span class="cov8" title="1">{
        currentFlagsets := m.buildCurrentFlagsetsMap()
        processedFlagsets := m.processNewFlagsets(newConfig.FlagSets, currentFlagsets)
        m.removeDeletedFlagsets(currentFlagsets, processedFlagsets)
        m.config.ForceReloadAPIKeys()
}</span>

// buildCurrentFlagsetsMap builds a map of current named flagsets.
func (m *flagsetManagerImpl) buildCurrentFlagsetsMap() map[string]config.FlagSet <span class="cov8" title="1">{
        currentFlagsets := make(map[string]config.FlagSet)
        for _, fs := range m.config.GetFlagSets() </span><span class="cov8" title="1">{
                if fs.Name != "" &amp;&amp; fs.Name != utils.DefaultFlagSetName </span><span class="cov8" title="1">{
                        currentFlagsets[fs.Name] = fs
                }</span>
        }
        <span class="cov8" title="1">return currentFlagsets</span>
}

// processNewFlagsets processes new flagsets from the config and returns a set of processed flagset names.
func (m *flagsetManagerImpl) processNewFlagsets(newFlagsets []config.FlagSet, currentFlagsets map[string]config.FlagSet) map[string]bool <span class="cov8" title="1">{
        processedFlagsets := make(map[string]bool)
        for _, newFS := range newFlagsets </span><span class="cov8" title="1">{
                if m.rejectUnnamedFlagset(newFS) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">processedFlagsets[newFS.Name] = true
                m.processFlagsetChange(newFS, currentFlagsets)</span>
        }
        <span class="cov8" title="1">return processedFlagsets</span>
}

// rejectUnnamedFlagset rejects unnamed flagsets and logs an error. Returns true if rejected.
func (m *flagsetManagerImpl) rejectUnnamedFlagset(flagset config.FlagSet) bool <span class="cov8" title="1">{
        if flagset.Name == "" || flagset.Name == utils.DefaultFlagSetName </span><span class="cov8" title="1">{
                m.logger.Error("Configuration change rejected: unnamed flagsets cannot be added or modified dynamically",
                        zap.String("flagset", flagset.Name))
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// processFlagsetChange processes a single flagset change (add, modify, or API key update).
func (m *flagsetManagerImpl) processFlagsetChange(newFS config.FlagSet, currentFlagsets map[string]config.FlagSet) <span class="cov8" title="1">{
        currentFS, exists := currentFlagsets[newFS.Name]
        if !exists </span><span class="cov0" title="0">{
                m.addFlagset(newFS)
                return
        }</span>

        <span class="cov8" title="1">if m.hasCommonFlagSetChanged(currentFS, newFS) </span><span class="cov0" title="0">{
                m.logger.Error("Configuration change rejected: flagset modification not allowed",
                        zap.String("flagset", newFS.Name),
                        zap.String("reason", "only API key changes are allowed for existing flagsets"))
                return
        }</span>

        <span class="cov8" title="1">m.processFlagsetAPIKeyChange(newFS)</span>
}

// removeDeletedFlagsets removes flagsets that no longer exist in the new config.
func (m *flagsetManagerImpl) removeDeletedFlagsets(currentFlagsets map[string]config.FlagSet, processedFlagsets map[string]bool) <span class="cov8" title="1">{
        for name := range currentFlagsets </span><span class="cov8" title="1">{
                if !processedFlagsets[name] </span><span class="cov0" title="0">{
                        m.removeFlagset(name)
                }</span>
        }
}

// processFlagsetAPIKeyChange handles API key changes for a single flagset.
func (m *flagsetManagerImpl) processFlagsetAPIKeyChange(newConfigFlagset config.FlagSet) <span class="cov8" title="1">{
        flagsetName := newConfigFlagset.Name
        if flagsetName == "" || flagsetName == utils.DefaultFlagSetName </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">currentAPIKeys, err := m.config.GetFlagSetAPIKeys(flagsetName)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if cmp.Equal(currentAPIKeys, newConfigFlagset.APIKeys) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m.logger.Info("Configuration changed: updating the APIKeys for flagset",
                zap.String("flagset", flagsetName))

        if err = m.config.SetFlagSetAPIKeys(flagsetName, newConfigFlagset.APIKeys); err != nil </span><span class="cov0" title="0">{
                m.logger.Error("failed to update the APIKeys for flagset", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">m.updateAPIKeysMapping(flagsetName, currentAPIKeys, newConfigFlagset.APIKeys)</span>
}

// updateAPIKeysMapping updates the APIKeysToFlagSetName map with the new API keys.
func (m *flagsetManagerImpl) updateAPIKeysMapping(flagsetName string, oldKeys, newKeys []string) <span class="cov8" title="1">{
        m.apiKeysMutex.Lock()
        defer m.apiKeysMutex.Unlock()

        for _, apiKey := range oldKeys </span><span class="cov8" title="1">{
                delete(m.APIKeysToFlagSetName, apiKey)
        }</span>
        <span class="cov8" title="1">for _, apiKey := range newKeys </span><span class="cov8" title="1">{
                m.APIKeysToFlagSetName[apiKey] = flagsetName
        }</span>
}

// hasCommonFlagSetChanged checks if the CommonFlagSet configuration has changed.
// This is used to detect forbidden modifications (everything except APIKeys).
func (m *flagsetManagerImpl) hasCommonFlagSetChanged(old, new config.FlagSet) bool <span class="cov8" title="1">{
        return !cmp.Equal(old.CommonFlagSet, new.CommonFlagSet,
                cmpopts.IgnoreUnexported(config.CommonFlagSet{}))
}</span>

// addFlagset creates a new flagset dynamically and starts it.
func (m *flagsetManagerImpl) addFlagset(flagset config.FlagSet) <span class="cov0" title="0">{
        // Create the GoFeatureFlag client (this automatically starts polling)
        client, err := NewGoFeatureFlagClient(&amp;flagset, m.logger, nil)
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Error("failed to create goff client for new flagset",
                        zap.String("flagset", flagset.Name),
                        zap.Error(err))
                return
        }</span>

        // Update config struct first (before adding to maps)
        <span class="cov0" title="0">if err := m.config.AddFlagSet(flagset); err != nil </span><span class="cov0" title="0">{
                m.logger.Error("failed to add flagset to config",
                        zap.String("flagset", flagset.Name),
                        zap.Error(err))
                client.Close()
                return
        }</span>

        // Add to FlagSets map and update API keys mapping (both protected by mutex)
        <span class="cov0" title="0">m.apiKeysMutex.Lock()
        m.FlagSets[flagset.Name] = client
        for _, apiKey := range flagset.APIKeys </span><span class="cov0" title="0">{
                m.APIKeysToFlagSetName[apiKey] = flagset.Name
        }</span>
        <span class="cov0" title="0">m.apiKeysMutex.Unlock()

        m.logger.Info("Configuration changed: added new flagset",
                zap.String("flagset", flagset.Name))</span>
}

// removeFlagset removes a flagset dynamically and gracefully stops it.
func (m *flagsetManagerImpl) removeFlagset(flagsetName string) <span class="cov0" title="0">{
        // Get API keys for this flagset before acquiring the lock
        apiKeysToRemove, err := m.config.GetFlagSetAPIKeys(flagsetName)
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Error("failed to get API keys for flagset to remove, API key mapping may be inconsistent",
                        zap.String("flagset", flagsetName),
                        zap.Error(err))
                apiKeysToRemove = []string{}
        }</span>

        // Get the client and remove from maps (protected by mutex)
        <span class="cov0" title="0">m.apiKeysMutex.Lock()
        client, exists := m.FlagSets[flagsetName]
        if !exists </span><span class="cov0" title="0">{
                m.apiKeysMutex.Unlock()
                m.logger.Warn("flagset not found for removal",
                        zap.String("flagset", flagsetName))
                return
        }</span>

        // Remove from FlagSets map and API keys mapping
        <span class="cov0" title="0">delete(m.FlagSets, flagsetName)
        for _, apiKey := range apiKeysToRemove </span><span class="cov0" title="0">{
                delete(m.APIKeysToFlagSetName, apiKey)
        }</span>
        <span class="cov0" title="0">m.apiKeysMutex.Unlock()

        // Gracefully stop the client (stops polling, flushes exports, closes notifiers)
        // Do this after releasing the lock to avoid blocking other operations
        client.Close()

        // Update config struct
        if err := m.config.RemoveFlagSet(flagsetName); err != nil </span><span class="cov0" title="0">{
                m.logger.Error("failed to remove flagset from config",
                        zap.String("flagset", flagsetName),
                        zap.Error(err))
                // Note: Client is already closed, but we log the error
                return
        }</span>

        <span class="cov0" title="0">m.logger.Info("Configuration changed: removed flagset",
                zap.String("flagset", flagsetName))</span>
}

// onConfigChangeWithDefault is called when the configuration changes in default mode.
// The only configuration that can be changed is the API Keys and the AuthorizedKeys.
// All the other configuration changes are not supported.
func (m *flagsetManagerImpl) onConfigChangeWithDefault(newConfig *config.Config) <span class="cov8" title="1">{
        reloadAPIKeys := false
        // on default mode, we can only change the API Keys, all the other configuration changes are not supported
        // We need to read the current values with proper locking to avoid data races
        currentAuthorizedKeys := m.config.GetAuthorizedKeys()
        currentAPIKeys := m.config.GetAPIKeys()
        newAuthorizedKeys := newConfig.GetAuthorizedKeys()
        newAPIKeys := newConfig.GetAPIKeys()

        if !cmp.Equal(m.config, newConfig,
                cmpopts.IgnoreUnexported(config.Config{}), cmpopts.IgnoreFields(config.Config{}, "APIKeys", "AuthorizedKeys")) </span><span class="cov0" title="0">{
                m.logger.Warn("Configuration changed not supported: only API Keys and AuthorizedKeys can be " +
                        "changed during runtime in default mode")
        }</span>

        <span class="cov8" title="1">if !cmp.Equal(currentAuthorizedKeys, newAuthorizedKeys, cmpopts.IgnoreUnexported(config.APIKeys{})) </span><span class="cov8" title="1">{
                m.logger.Info("Configuration changed: reloading the AuthorizedKeys")
                m.config.SetAuthorizedKeys(newAuthorizedKeys)
                reloadAPIKeys = true
        }</span>

        // nolint: staticcheck
        <span class="cov8" title="1">if !cmp.Equal(currentAPIKeys, newAPIKeys) </span><span class="cov8" title="1">{
                m.logger.Info("Configuration changed: reloading the APIKeys")
                // nolint: staticcheck
                m.config.SetAPIKeys(newAPIKeys)
                reloadAPIKeys = true
        }</span>

        <span class="cov8" title="1">if reloadAPIKeys </span><span class="cov8" title="1">{
                m.config.ForceReloadAPIKeys()
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package service

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "dario.cat/mergo"
        "github.com/IBM/sarama"
        awsConf "github.com/aws/aws-sdk-go-v2/config"
        slogzap "github.com/samber/slog-zap/v2"
        ffclient "github.com/thomaspoignant/go-feature-flag"
        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/config"
        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/config/kafka"
        retrieverInit "github.com/thomaspoignant/go-feature-flag/cmdhelpers/retrieverconf/init"
        "github.com/thomaspoignant/go-feature-flag/exporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/azureexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/fileexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/gcstorageexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/kafkaexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/kinesisexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/logsexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/opentelemetryexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/pubsubexporterv2"
        "github.com/thomaspoignant/go-feature-flag/exporter/s3exporterv2"
        "github.com/thomaspoignant/go-feature-flag/exporter/sqsexporter"
        "github.com/thomaspoignant/go-feature-flag/exporter/webhookexporter"
        "github.com/thomaspoignant/go-feature-flag/notifier"
        "github.com/thomaspoignant/go-feature-flag/notifier/discordnotifier"
        "github.com/thomaspoignant/go-feature-flag/notifier/microsoftteamsnotifier"
        "github.com/thomaspoignant/go-feature-flag/notifier/slacknotifier"
        "github.com/thomaspoignant/go-feature-flag/notifier/webhooknotifier"
        "github.com/thomaspoignant/go-feature-flag/retriever"
        "github.com/thomaspoignant/go-feature-flag/utils"
        "go.uber.org/zap"
)

func NewGoFeatureFlagClient(
        cFlagSet *config.FlagSet,
        logger *zap.Logger,
        notifiers []notifier.Notifier,
) (*ffclient.GoFeatureFlag, error) <span class="cov8" title="1">{
        var err error
        if cFlagSet == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("proxy config is empty")
        }</span>

        <span class="cov8" title="1">retrievers, err := initRetrievers(cFlagSet)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">exporters, err := initDataExporters(cFlagSet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">notif := make([]notifier.Notifier, 0, len(notifiers))
        if cFlagSet.Notifiers != nil </span><span class="cov0" title="0">{
                notif, err = initNotifier(cFlagSet.Notifiers)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // backward compatibility for the notifier field, it was called "notifier" instead of "notifiers"
        // fixed in version v1.46.0
        <span class="cov8" title="1">if len(notif) == 0 &amp;&amp; cFlagSet.FixNotifiers != nil </span><span class="cov0" title="0">{ // nolint: staticcheck
                notif, err = initNotifier(cFlagSet.FixNotifiers) // nolint: staticcheck
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        // end of backward compatibility for the notifier field in version v1.66.0
        <span class="cov8" title="1">notif = append(notif, notifiers...)

        f := ffclient.Config{
                PollingInterval: time.Duration(
                        cFlagSet.PollingInterval,
                ) * time.Millisecond,
                LeveledLogger:                   initLeveledLogger(cFlagSet, logger),
                Context:                         context.Background(),
                Retrievers:                      retrievers,
                Notifiers:                       notif,
                FileFormat:                      cFlagSet.FileFormat,
                DataExporters:                   exporters,
                StartWithRetrieverError:         cFlagSet.StartWithRetrieverError,
                EnablePollingJitter:             cFlagSet.EnablePollingJitter,
                DisableNotifierOnInit:           cFlagSet.DisableNotifierOnInit,
                EvaluationContextEnrichment:     cFlagSet.EvaluationContextEnrichment,
                PersistentFlagConfigurationFile: cFlagSet.PersistentFlagConfigurationFile,
                Name:                            &amp;cFlagSet.Name,
        }
        client, err := ffclient.New(f)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return client, nil</span>
}

// initLeveledLogger initializes the leveled logger
// it will add the flagset name as a contextual attribute if it is not the default flagset
func initLeveledLogger(c *config.FlagSet, logger *zap.Logger) *slog.Logger <span class="cov8" title="1">{
        baseHandler := slogzap.Option{Level: slog.LevelDebug, Logger: logger}.NewZapHandler()
        if c.Name != "" &amp;&amp; c.Name != utils.DefaultFlagSetName </span><span class="cov8" title="1">{
                attrs := []slog.Attr{slog.String("flagset", c.Name)}
                baseHandler = baseHandler.WithAttrs(attrs)
        }</span>
        <span class="cov8" title="1">return slog.New(baseHandler)</span>
}

// initRetrievers initialize the retrievers based on the configuration
// it handles both the `retriever` and `retrievers` fields
func initRetrievers(proxyConf *config.FlagSet) ([]retriever.Retriever, error) <span class="cov8" title="1">{
        retrievers := make([]retriever.Retriever, 0)
        // if the retriever is set, we add it to the retrievers
        if proxyConf.Retriever != nil </span><span class="cov8" title="1">{
                currentRetriever, err := retrieverInit.InitRetriever(proxyConf.Retriever)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">retrievers = append(retrievers, currentRetriever)</span>
        }
        // if the retrievers are set, we add them to the retrievers
        <span class="cov8" title="1">if proxyConf.Retrievers != nil </span><span class="cov8" title="1">{
                for _, r := range *proxyConf.Retrievers </span><span class="cov8" title="1">{
                        currentRetriever, err := retrieverInit.InitRetriever(&amp;r)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">retrievers = append(retrievers, currentRetriever)</span>
                }
        }
        <span class="cov8" title="1">return retrievers, nil</span>
}

// initDataExporters initialize the exporters based on the configuration
// it handles both the `exporter` and `exporters` fields.
func initDataExporters(proxyConf *config.FlagSet) ([]ffclient.DataExporter, error) <span class="cov8" title="1">{
        exporters := make([]ffclient.DataExporter, 0)
        if proxyConf.Exporter != nil </span><span class="cov0" title="0">{
                currentExporter, err := initDataExporter(proxyConf.Exporter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">exporters = append(exporters, currentExporter)</span>
        }
        <span class="cov8" title="1">if proxyConf.Exporters != nil </span><span class="cov8" title="1">{
                for _, e := range *proxyConf.Exporters </span><span class="cov8" title="1">{
                        currentExporter, err := initDataExporter(&amp;e)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">exporters = append(exporters, currentExporter)</span>
                }
        }

        <span class="cov8" title="1">return exporters, nil</span>
}

func initDataExporter(c *config.ExporterConf) (ffclient.DataExporter, error) <span class="cov8" title="1">{
        exporterEventType := c.ExporterEventType
        if exporterEventType == "" </span><span class="cov8" title="1">{
                exporterEventType = config.DefaultExporter.ExporterEventType
        }</span>
        <span class="cov8" title="1">dataExp := ffclient.DataExporter{
                FlushInterval: func() time.Duration </span><span class="cov8" title="1">{
                        if c.FlushInterval != 0 </span><span class="cov8" title="1">{
                                return time.Duration(c.FlushInterval) * time.Millisecond
                        }</span>
                        <span class="cov8" title="1">return config.DefaultExporter.FlushInterval</span>
                }(),
                MaxEventInMemory: func() int64 <span class="cov8" title="1">{
                        if c.MaxEventInMemory != 0 </span><span class="cov8" title="1">{
                                return c.MaxEventInMemory
                        }</span>
                        <span class="cov8" title="1">return config.DefaultExporter.MaxEventInMemory</span>
                }(),
                ExporterEventType: exporterEventType,
        }

        <span class="cov8" title="1">var err error
        dataExp.Exporter, err = createExporter(c)
        if err != nil </span><span class="cov8" title="1">{
                return ffclient.DataExporter{}, err
        }</span>

        <span class="cov8" title="1">return dataExp, nil</span>
}

// nolint: funlen
func createExporter(c *config.ExporterConf) (exporter.CommonExporter, error) <span class="cov8" title="1">{
        format := config.DefaultExporter.Format
        if c.Format != "" </span><span class="cov0" title="0">{
                format = c.Format
        }</span>

        <span class="cov8" title="1">filename := config.DefaultExporter.FileName
        if c.Filename != "" </span><span class="cov0" title="0">{
                filename = c.Filename
        }</span>

        <span class="cov8" title="1">csvTemplate := config.DefaultExporter.CsvFormat
        if c.CsvTemplate != "" </span><span class="cov0" title="0">{
                csvTemplate = c.CsvTemplate
        }</span>

        <span class="cov8" title="1">parquetCompressionCodec := config.DefaultExporter.ParquetCompressionCodec
        if c.ParquetCompressionCodec != "" </span><span class="cov8" title="1">{
                parquetCompressionCodec = c.ParquetCompressionCodec
        }</span>

        <span class="cov8" title="1">switch c.Kind </span>{
        case config.WebhookExporter:<span class="cov8" title="1">
                return &amp;webhookexporter.Exporter{
                        EndpointURL: c.EndpointURL,
                        Secret:      c.Secret,
                        Meta:        c.Meta,
                        Headers:     c.Headers,
                }, nil</span>
        case config.FileExporter:<span class="cov8" title="1">
                return &amp;fileexporter.Exporter{
                        Format:                  format,
                        OutputDir:               c.OutputDir,
                        Filename:                filename,
                        CsvTemplate:             csvTemplate,
                        ParquetCompressionCodec: parquetCompressionCodec,
                }, nil</span>
        case config.LogExporter:<span class="cov8" title="1">
                return &amp;logsexporter.Exporter{
                        LogFormat: func() string </span><span class="cov8" title="1">{
                                if c.LogFormat != "" </span><span class="cov0" title="0">{
                                        return c.LogFormat
                                }</span>
                                <span class="cov8" title="1">return config.DefaultExporter.LogFormat</span>
                        }(),
                }, nil
        case config.S3Exporter:<span class="cov8" title="1">
                awsConfig, err := awsConf.LoadDefaultConfig(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return &amp;s3exporterv2.Exporter{
                        Bucket:                  c.Bucket,
                        Format:                  format,
                        S3Path:                  c.Path,
                        Filename:                filename,
                        CsvTemplate:             csvTemplate,
                        ParquetCompressionCodec: parquetCompressionCodec,
                        AwsConfig:               &amp;awsConfig,
                }, nil</span>
        case config.KinesisExporter:<span class="cov8" title="1">
                awsConfig, err := awsConf.LoadDefaultConfig(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;kinesisexporter.Exporter{
                        Format:    format,
                        AwsConfig: &amp;awsConfig,
                        Settings: kinesisexporter.NewSettings(
                                kinesisexporter.WithStreamArn(c.StreamArn),
                                kinesisexporter.WithStreamName(c.StreamName),
                        ),
                }, nil</span>
        case config.GoogleStorageExporter:<span class="cov8" title="1">
                return &amp;gcstorageexporter.Exporter{
                        Bucket:                  c.Bucket,
                        Format:                  format,
                        Path:                    c.Path,
                        Filename:                filename,
                        CsvTemplate:             csvTemplate,
                        ParquetCompressionCodec: parquetCompressionCodec,
                }, nil</span>
        case config.SQSExporter:<span class="cov8" title="1">
                awsConfig, err := awsConf.LoadDefaultConfig(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;sqsexporter.Exporter{
                        QueueURL:  c.QueueURL,
                        AwsConfig: &amp;awsConfig,
                }, nil</span>
        case config.KafkaExporter:<span class="cov8" title="1">
                settings, err := setKafkaConfig(c.Kafka)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;kafkaexporter.Exporter{
                        Format:   format,
                        Settings: settings,
                }, nil</span>
        case config.PubSubExporter:<span class="cov8" title="1">
                return &amp;pubsubexporterv2.Exporter{
                        ProjectID: c.ProjectID,
                        Topic:     c.Topic,
                }, nil</span>
        case config.AzureExporter:<span class="cov8" title="1">
                return &amp;azureexporter.Exporter{
                        Container:               c.Container,
                        Format:                  format,
                        Path:                    c.Path,
                        Filename:                filename,
                        CsvTemplate:             csvTemplate,
                        ParquetCompressionCodec: parquetCompressionCodec,
                        AccountKey:              c.AccountKey,
                        AccountName:             c.AccountName,
                }, nil</span>
        case config.OpenTelemetryExporter:<span class="cov0" title="0">
                return &amp;opentelemetryexporter.Exporter{
                        TracerName: c.TracerName,
                }, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("invalid exporter: kind \"%s\" is not supported", c.Kind)</span>
        }
}

// setKafkaConfig set the kafka configuration based on the default configuration
// it will initialize the default configuration and merge it with the changes from the user.
func setKafkaConfig(k kafkaexporter.Settings) (kafkaexporter.Settings, error) <span class="cov8" title="1">{
        c := kafkaexporter.Settings{
                Topic:     k.Topic,
                Addresses: k.Addresses,
        }

        if k.Config == nil </span><span class="cov8" title="1">{
                return c, nil
        }</span>
        <span class="cov8" title="1">saramaConfig := sarama.NewConfig()
        err := mergo.Merge(saramaConfig, k.Config)
        if err != nil </span><span class="cov0" title="0">{
                return kafkaexporter.Settings{}, err
        }</span>
        <span class="cov8" title="1">saramaConfig.Producer.Return.Errors = true

        switch saramaConfig.Net.SASL.Mechanism </span>{
        case sarama.SASLTypeSCRAMSHA256:<span class="cov8" title="1">
                saramaConfig.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient </span><span class="cov0" title="0">{
                        return &amp;kafka.XDGSCRAMClient{HashGeneratorFcn: kafka.SHA256}
                }</span>
        case sarama.SASLTypeSCRAMSHA512:<span class="cov8" title="1">
                saramaConfig.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient </span><span class="cov0" title="0">{
                        return &amp;kafka.XDGSCRAMClient{HashGeneratorFcn: kafka.SHA512}
                }</span>
        }
        <span class="cov8" title="1">c.Config = saramaConfig
        return c, nil</span>
}

func initNotifier(c []config.NotifierConf) ([]notifier.Notifier, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var notifiers []notifier.Notifier

        for _, cNotif := range c </span><span class="cov8" title="1">{
                switch cNotif.Kind </span>{
                case config.SlackNotifier:<span class="cov8" title="1">
                        if cNotif.WebhookURL == "" &amp;&amp; cNotif.SlackWebhookURL != "" </span><span class="cov0" title="0">{ // nolint
                                zap.L().Warn("slackWebhookURL field is deprecated, please use webhookURL instead")
                                cNotif.WebhookURL = cNotif.SlackWebhookURL // nolint
                        }</span>
                        <span class="cov8" title="1">notifiers = append(
                                notifiers,
                                &amp;slacknotifier.Notifier{SlackWebhookURL: cNotif.WebhookURL},
                        )</span>
                case config.MicrosoftTeamsNotifier:<span class="cov8" title="1">
                        notifiers = append(
                                notifiers,
                                &amp;microsoftteamsnotifier.Notifier{
                                        MicrosoftTeamsWebhookURL: cNotif.WebhookURL,
                                },
                        )</span>
                case config.WebhookNotifier:<span class="cov8" title="1">
                        notifiers = append(notifiers,
                                &amp;webhooknotifier.Notifier{
                                        Secret:      cNotif.Secret,
                                        EndpointURL: cNotif.EndpointURL,
                                        Meta:        cNotif.Meta,
                                        Headers:     cNotif.Headers,
                                },
                        )</span>
                case config.DiscordNotifier:<span class="cov8" title="1">
                        notifiers = append(
                                notifiers,
                                &amp;discordnotifier.Notifier{DiscordWebhookURL: cNotif.WebhookURL},
                        )</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid notifier: kind \"%s\" is not supported", cNotif.Kind)</span>
                }
        }
        <span class="cov8" title="1">return notifiers, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package service

import (
        "fmt"
        "time"

        "github.com/thomaspoignant/go-feature-flag/cmd/relayproxy/model"
)

// Monitoring is the interface of the monitoring service
type Monitoring interface {
        Health() model.HealthResponse
        Info() (model.InfoResponse, error)
}

// NewMonitoring creates a new implementation of Monitoring
func NewMonitoring(flagsetManager FlagsetManager) Monitoring <span class="cov8" title="1">{
        return &amp;monitoringImpl{
                flagsetManager: flagsetManager,
        }
}</span>

// monitoringImpl is one implementation of the Monitoring interface
type monitoringImpl struct {
        flagsetManager FlagsetManager
}

// Health returns a static object to show that the server is initialized
func (m *monitoringImpl) Health() model.HealthResponse <span class="cov8" title="1">{
        return model.HealthResponse{
                Initialized: true,
        }
}</span>

// Info returns information about the relay-proxy
func (m *monitoringImpl) Info() (model.InfoResponse, error) <span class="cov8" title="1">{
        if m.flagsetManager == nil </span><span class="cov8" title="1">{
                return model.InfoResponse{}, fmt.Errorf("flagset manager is not initialized")
        }</span>
        <span class="cov8" title="1">flagSets, err := m.flagsetManager.AllFlagSets()
        if err != nil </span><span class="cov8" title="1">{
                return model.InfoResponse{}, err
        }</span>

        <span class="cov8" title="1">if m.flagsetManager.IsDefaultFlagSet() </span><span class="cov8" title="1">{
                if m.flagsetManager.Default() == nil </span><span class="cov8" title="1">{
                        return model.InfoResponse{}, fmt.Errorf("no default flagset configured")
                }</span>
                <span class="cov8" title="1">cacheRefreshDate := m.flagsetManager.Default().GetCacheRefreshDate()
                return model.InfoResponse{
                        LatestCacheRefresh: &amp;cacheRefreshDate,
                }, nil</span>
        }

        <span class="cov8" title="1">refreshDates := make(map[string]time.Time, len(flagSets))
        latestRefreshDate := time.Time{}
        for flagsetName, flagset := range flagSets </span><span class="cov8" title="1">{
                refreshDates[flagsetName] = flagset.GetCacheRefreshDate()
                if refreshDates[flagsetName].After(latestRefreshDate) </span><span class="cov8" title="1">{
                        latestRefreshDate = refreshDates[flagsetName]
                }</span>
        }
        <span class="cov8" title="1">return model.InfoResponse{
                Flagsets:           refreshDates,
                LatestCacheRefresh: &amp;latestRefreshDate,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package service

import (
        "github.com/thomaspoignant/go-feature-flag/notifier"
)

type notifierWebsocket struct {
        websocketService WebsocketService
}

func NewNotifierWebsocket(websocketService WebsocketService) notifier.Notifier <span class="cov8" title="1">{
        return &amp;notifierWebsocket{
                websocketService: websocketService,
        }
}</span>

func (n *notifierWebsocket) Notify(diff notifier.DiffCache) error <span class="cov8" title="1">{
        n.websocketService.BroadcastFlagChanges(diff)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package service

import (
        "context"
        "sync"
        "time"

        "github.com/thomaspoignant/go-feature-flag/notifier"
)

// WebsocketConnector is an interface to be able to mock websocket.Conn
type WebsocketConnector interface {
        WriteJSON(v any) error
}

// WebsocketService is the service interface that handle the websocket connections
// This service is able to broadcast a notification to all the open websockets
type WebsocketService interface {
        // Register is adding the connection to the list of open connection.
        Register(c WebsocketConnector)
        // Deregister is removing the connection from the list of open connection.
        Deregister(c WebsocketConnector)
        // BroadcastFlagChanges is sending the diff cache struct to the client.
        BroadcastFlagChanges(diff notifier.DiffCache)
        // Close deregister all open connections.
        Close()
        // WaitForCleanup waits for all connections to be properly closed
        WaitForCleanup(timeout time.Duration) error
}

// NewWebsocketService is a constructor to create a new WebsocketService.
func NewWebsocketService() WebsocketService <span class="cov8" title="1">{
        return &amp;websocketServiceImpl{
                clients: map[WebsocketConnector]any{},
                mutex:   &amp;sync.RWMutex{},
                closed:  make(chan struct{}),
        }
}</span>

// websocketServiceImpl is the implementation of the interface.
type websocketServiceImpl struct {
        clients map[WebsocketConnector]any
        mutex   *sync.RWMutex
        closed  chan struct{}
}

// BroadcastFlagChanges is sending a string to all the open connection.
func (w *websocketServiceImpl) BroadcastFlagChanges(diff notifier.DiffCache) <span class="cov8" title="1">{
        w.mutex.RLock()
        defer w.mutex.RUnlock()
        for c := range w.clients </span><span class="cov8" title="1">{
                err := c.WriteJSON(diff)
                if err != nil </span><span class="cov8" title="1">{
                        w.mutex.RUnlock()
                        w.Deregister(c)
                        w.mutex.RLock()
                }</span>
        }
}

// Register is adding the connection to the list of open connection.
func (w *websocketServiceImpl) Register(c WebsocketConnector) <span class="cov8" title="1">{
        w.mutex.Lock()
        defer w.mutex.Unlock()
        w.clients[c] = struct{}{}
}</span>

// Deregister is removing the connection from the list of open connection.
func (w *websocketServiceImpl) Deregister(c WebsocketConnector) <span class="cov8" title="1">{
        w.mutex.Lock()
        defer w.mutex.Unlock()
        delete(w.clients, c)
}</span>

// Close deregister all open connections.
func (w *websocketServiceImpl) Close() <span class="cov8" title="1">{
        w.mutex.Lock()
        defer w.mutex.Unlock()
        for c := range w.clients </span><span class="cov8" title="1">{
                delete(w.clients, c)
        }</span>
        <span class="cov8" title="1">close(w.closed)</span>
}

// WaitForCleanup waits for all connections to be properly closed
func (w *websocketServiceImpl) WaitForCleanup(timeout time.Duration) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        select </span>{
        case &lt;-w.closed:<span class="cov0" title="0">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
